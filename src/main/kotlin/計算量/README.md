# 時間計算量（Time Complexity）

プログラム（アルゴリズム）が処理を終えるまでにかかるステップ数（時間）を、入力サイズ（n）に対して表したものです。

たとえば、リストにn個の要素があるときに、それを順番に見ると、だいたいn回の操作が必要ですよね。

主に「オーダー記法（ビッグオー記法）」で表します。

| 処理内容           | 時間計算量       | 例              |
|----------------|-------------|----------------|
| 入力が増えても処理回数が一定 | O(1)（定数時間）  | 配列の特定の要素を取得する  |
| 入力サイズに比例       | O(n)（線形時間）  | 配列を1回全部見る      |
| 入力サイズの二乗に比例    | O(n²)（二次時間） | 二重ループで全てのペアを見る |
| すごく速く増える       | O(2ⁿ)（指数時間） | 全ての組み合わせを試す    |

# 空間計算量（Space Complexity）

プログラムが動くために必要なメモリ（記憶領域）の量を、入力サイズ（n）に対して表したものです。

たとえば、リストのコピーを作ると元のリストと同じ大きさのメモリがもう一個必要ですよね。

これも時間計算量と同じく、オーダー記法で表します。

| 使用メモリ       | 空間計算量 | 例             |
|-------------|-------|---------------|
| 入力に関係なく一定   | O(1)  | 変数1個だけ使う      |
| 入力サイズに比例    | O(n)  | 配列のコピーを作る     |
| 入力サイズの二乗に比例 | O(n²) | 2次元配列（n×n）を使う |

***

# 複雑性クラス

アルゴリズムや問題の「どれくらい難しいか」を分類するためのグループのこと。

主に「時間計算量」や「空間計算量」の成長のしかたでクラス分けします。

その中でよく出てくるのが、O(1)、O(n)、O(log n)、O(n²)、などです！

## 複雑性クラスの主な定数（オーダー）

| 記号         | 名前     | 説明                                  | 例                     |
|------------|--------|-------------------------------------|-----------------------|
| O(1)       | 定数時間   | 入力サイズに関係なく処理回数が一定                   | 配列のインデックスを取得する        |                        |
| O(log n)   | 対数時間   | 入力サイズが大きくなると処理回数はゆっくり増える            | 二分探索                  |                          |
| O(n)       | 線形時間   | 入力サイズに比例して処理回数が増える                  | 配列を全部見る               |                           |
| O(n log n) | 線形対数時間 | ほぼ線形だけどちょっと重い（n回の中でさらにlog n回やるイメージ） | 高速ソート（マージソート、クイックソート） |
| O(n²)      | 二次時間   | 入力サイズが増えるとめっちゃ速く処理回数が増える（n×n）       | バブルソート、選択ソート          |
| O(2ⁿ)      | 指数時間   | 入力がちょっと増えるだけで爆発的に処理回数が増える           | 部分集合列挙（すべてのパターンを試す）   |
| O(n!)      | 階乗時間   | n!（n×(n-1)×(n-2)…）なので超超爆発的に増える      | ナイーブな巡回セールスマン問題       |

## 重要なポイント

実際のプログラムでは、できるだけ低いオーダーのアルゴリズムを使いたい！（O(1)やO(log n)が理想）

O(n²) や O(2ⁿ) は、小さいnなら動くけど、大きくなると「終わらない...😇」ってなる。

特にソートアルゴリズム、探索アルゴリズム、グラフアルゴリズムなどでこの「複雑性クラス」を意識することが多い！

# 計算量を意識した設計

## 時間優先（スピード重視）の設計とは？

できるだけ早く答えを出すことを最優先！

多少メモリをたくさん使ってもいい！

* キャッシュを使う
    * 計算結果をメモリに保存して、次からは即答できるようにする

* 事前計算する（プリコンピュート）
    * 必要になりそうなものを先に計算してメモリに持っておく

* 並列処理（マルチスレッド）する
    * 複数CPUコアを使って時間短縮する

💬 例：

* 大量アクセスがくるWeb API（速く返さないとタイムアウト）
* ゲームでのキャラクター動き計算（ラグったらプレイヤー離脱）
* 株価トレードアルゴリズム（1ミリ秒勝負）

## 空間優先（メモリ重視）の設計とは？

できるだけメモリを節約することを最優先！

計算を多少やり直してもいい！（再計算してもOK）

* ストリーム処理する
    * 必要なデータだけ少しずつ読む、全部は持たない

* インプレース（その場）更新する
    * 新しいデータ構造を作らず、既存のデータを書き換える
    * ミュータブルなコード

* 再帰よりループで書く
    * スタックメモリ節約！

💬 例：

* スマホアプリ（端末メモリが少ない）
* IoT機器（数十MBしかRAMがない）
* ビッグデータ処理（メモリに全部乗らないから1行ずつ読む）

# チューニングの具体例

| チューニング方法 | どちらを優先？ | トレードオフするもの    |
|----------|---------|---------------|
| キャッシュ    | 時間優先    | メモリを多く使う      |
| ストリーム処理  | 空間優先    | 処理時間が少し増える    |
| データ構造最適化 | 時間優先    | メモリ多めに使うことも   |
| インプレース更新 | 空間優先    | データの一時保存ができない |

何を優先するか（時間か空間か）を明確にして設計する！  
どちらも無限にチューニングできるわけじゃない。  
プロジェクトや機能ごとに「今回は時間優先！」「今回はメモリ優先！」をちゃんと決めるのがプロの設計です